<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MMF Schema Graph Interactive Editor (ZIP+Code Matched)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 0;
      padding: 24px;
      color: #111;
      background: #f9fafb;
    }
    .toolbar {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
    }
    button {
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid #111;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: #f6f6f6; }
    .card {
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
      overflow: auto;
    }
    .info {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }
    .checkedPanel{
      background:#ecfeff;
      border:1px solid #06b6d4;
      padding:14px 16px;
      border-radius:10px;
      margin-bottom:16px;
      font-size:13px;
    }
    .checkedPanel h3{
      margin:0 0 10px 0;
      font-size:14px;
    }
    .checkedPanel .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px 18px;
    }
    .checkedPanel ul{ margin:8px 0 0 18px; padding:0; }
    .checkedPanel li{ margin:4px 0; line-height:1.3; }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      border:1px solid #111;
      background:#fff;
      margin-left:8px;
    }
    .badge.ok{ border-color:#16a34a; color:#16a34a; }
    .badge.warn{ border-color:#dc2626; color:#dc2626; }
    .badge.meta{ border-color:#0284c7; color:#0284c7; }
    #canvas { cursor: grab; user-select: none; }
    #canvas.dragging { cursor: grabbing; }
    .node-dragging { cursor: move !important; }
    input[type="range"] { width: 120px; }
    label { font-size: 13px; font-weight: 600; margin-left: 12px; }
    .muted { color:#334155; }
    code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <h1 style="margin:0 0 16px 0;">MMF Schema Graph Interactive Editor (ZIP + Code Matched)</h1>

  <div class="info">
    <strong>How to use:</strong>
    Drag nodes to reposition | Right-click a node to resize | Drag edge labels to reposition | Save/Load the layout as JSON
    <div class="muted" style="margin-top:6px;">
      This graph matches the MMF extractor outputs in the ZIP (<code>normalized/*.csv.gz</code>, <code>normalized/*.jsonl.gz</code>, <code>normalized/manifest.*</code>) plus <code>qc_summary.json</code> at out_dir root.
      Sub-text wrapping is done with SVG <code>&lt;tspan&gt;</code> (no scaling / no stretching) and clipped to the circle.
    </div>
  </div>

  <div class="checkedPanel" id="checkedPanel">
    <h3>
      Checked elements
      <span class="badge meta" id="validatedBadge">Validating...</span>
      <span class="badge meta" id="countsBadge"></span>
    </h3>
    <div class="grid">
      <div>
        <strong>Nodes</strong>
        <ul id="checkedNodes"></ul>
      </div>
      <div>
        <strong>Edges</strong>
        <ul id="checkedEdges"></ul>
      </div>
    </div>
    <div style="margin-top:10px; color:#0f172a;">
      <strong>Join semantics (extractor-aligned):</strong>
      <ul>
        <li><code>ImageTextPairs</code> is the pair table keyed by <code>pair_id</code> and links <code>image_uid</code> â†” <code>text_uid</code>.</li>
        <li><code>Images</code> is keyed by <code>image_uid</code> and carries both <code>image_id</code> and <code>image_id_raw</code>.</li>
        <li><code>Texts</code> is keyed by <code>text_uid</code> (one caption per row).</li>
        <li><code>Items</code> is a lightweight typed registry: <code>(item_uid, item_type, ref_uid)</code> (conceptual joins to Images/Texts via <code>ref_uid</code> depending on <code>item_type</code>).</li>
        <li><code>KeypointsRaw</code> is optional JSONL keyed by <code>image_uid</code> (and repeats <code>image_id</code>, <code>image_id_raw</code>).</li>
        <li><code>MasksIndex</code> is optional; joins to Images via <code>image_uid</code>.</li>
        <li><code>Manifest</code> and <code>QCSummary</code> are run-level artifacts (conceptual edges).</li>
      </ul>
    </div>
  </div>

  <div class="toolbar">
    <button onclick="downloadSVG()">ðŸ“¥ Download SVG</button>
    <button onclick="downloadHTML()">ðŸ“¥ Download HTML</button>
    <button onclick="saveConfig()">ðŸ’¾ Save Layout (JSON)</button>
    <button onclick="loadConfig()">ðŸ“‚ Load Layout</button>
    <button onclick="resetGraph()">ðŸ”„ Reset</button>
    <label>Zoom: <input type="range" id="zoomSlider" min="50" max="150" value="100" oninput="updateZoom(this.value)"></label>
    <span id="zoomLevel">100%</span>
  </div>

  <div class="card">
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg" width="1600" height="1000" viewBox="0 0 1600 1000">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#111"/>
        </marker>

        <style>
          .node { fill:#fff; stroke:#111; stroke-width:2.2; cursor: move; }
          .node:hover { stroke:#0066cc; stroke-width:3; }
          .nodeCenter { fill:#f0f9ff; stroke:#0066cc; stroke-width:2.5; cursor: move; }
          .nodeCenter:hover { stroke:#0044aa; stroke-width:3; }
          .nodeMeta { fill:#fff7ed; stroke:#c2410c; stroke-width:2.3; cursor: move; }
          .nodeMeta:hover { stroke:#9a3412; stroke-width:3; }

          .label { font:700 13px system-ui; fill:#111; pointer-events: none; }
          .sub { font:400 10.5px system-ui; fill:#555; pointer-events: none; }

          .edge { stroke:#111; stroke-width:2.1; fill:none; marker-end:url(#arrow); }
          .edgeMeta { stroke:#c2410c; stroke-width:2.1; fill:none; marker-end:url(#arrow); stroke-dasharray:7 6; }
          .edgeLabel { font:600 11px system-ui; fill:#111; cursor: move; }
          .pill { fill:#f3f4f6; stroke:#111; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pill:hover { fill:#e5e7eb; }
          .pillMeta { fill:#fff7ed; stroke:#c2410c; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pillMeta:hover { fill:#ffedd5; }
        </style>
      </defs>

      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
  </div>

<script>
/**
 * MMF graph updated to match the attached mmf_fel_out.zip headers exactly.
 * IMPORTANT: sub text inside circle
 * - NO scaling (NO textLength/lengthAdjust/transform scale)
 * - Wrap by tspans (font size unchanged)
 * - Clip to circle
 */

// âœ… ZIP-matched JSON (nodes/edges + positions)
const initialData = {
  "nodes": [
    {
      "id": "pairs",
      "label": "ImageTextPairs",
      "sub1": "image_text_pairs.csv.gz",
      "sub2": "(pair_id, image_uid, text_uid, split, src_file, row_index)",
      "x": 820,
      "y": 470,
      "r": 110,
      "center": true
    },
    {
      "id": "images",
      "label": "Images",
      "sub1": "images.csv.gz",
      "sub2": "(image_uid, image_id, image_id_raw, image_file, split, src_file, row_index)",
      "x": 520,
      "y": 260,
      "r": 92
    },
    {
      "id": "texts",
      "label": "Texts",
      "sub1": "texts.csv.gz",
      "sub2": "(text_uid, text, split, src_file, row_index)",
      "x": 1123,
      "y": 270,
      "r": 92
    },
    {
      "id": "items",
      "label": "Items",
      "sub1": "items.csv.gz",
      "sub2": "(item_uid, item_type, ref_uid)",
      "x": 815,
      "y": 104,
      "r": 92
    },
    {
      "id": "kpt",
      "label": "KeypointsRaw",
      "sub1": "keypoints_raw.jsonl.gz",
      "sub2": "(image_uid, image_id, image_id_raw, loc, vis, src_loc, src_vis)",
      "x": 704,
      "y": 697,
      "r": 92
    },
    {
      "id": "masks",
      "label": "MasksIndex",
      "sub1": "masks_index.csv.gz",
      "sub2": "(image_uid, mask_file, split, src_file, row_index)",
      "x": 426,
      "y": 555,
      "r": 88
    },
    {
      "id": "manifest",
      "label": "Manifest",
      "sub1": "manifest.csv",
      "sub2": "(relative_path, ext, size_bytes, mtime_iso) + manifest.jsonl",
      "x": 1195,
      "y": 542,
      "r": 88
    },
    {
      "id": "qc",
      "label": "QCSummary",
      "sub1": "qc_summary.json",
      "sub2": "(counts, warnings, errors, hard_fail, inputs, optional)",
      "x": 1026,
      "y": 698,
      "r": 90,
      "meta": true
    }
  ],
  "edges": [
    { "from": "pairs", "to": "images", "label": "image_uid", "labelX": 675, "labelY": 343 },
    { "from": "pairs", "to": "texts",  "label": "text_uid",  "labelX": 986, "labelY": 385 },

    { "from": "images", "to": "masks", "label": "image_uid", "labelX": 446, "labelY": 398 },
    { "from": "images", "to": "kpt",   "label": "image_uid", "labelX": 584, "labelY": 500 },

    { "from": "items", "to": "images", "label": "ref_uid (image)", "labelX": 665, "labelY": 164 },
    { "from": "items", "to": "texts",  "label": "ref_uid (text)",  "labelX": 953, "labelY": 197 },

    { "from": "pairs", "to": "manifest", "label": "input audit",  "labelX": 1004, "labelY": 526 },
    { "from": "pairs", "to": "qc",       "label": "run metadata", "labelX": 908,  "labelY": 601 }
  ]
};

const checkedSpec = {
  nodes: [
    "ImageTextPairs (image_text_pairs.csv.gz)",
    "Images (images.csv.gz)",
    "Texts (texts.csv.gz)",
    "Items (items.csv.gz)",
    "KeypointsRaw (keypoints_raw.jsonl.gz; optional)",
    "MasksIndex (masks_index.csv.gz; optional)",
    "Manifest (manifest.csv / manifest.jsonl)",
    "QCSummary (qc_summary.json)"
  ],
  edges: [
    "ImageTextPairsâ†’Images (image_uid)",
    "ImageTextPairsâ†’Texts (text_uid)",
    "Imagesâ†’MasksIndex (image_uid; optional)",
    "Imagesâ†’KeypointsRaw (image_uid; optional)",
    "Itemsâ†’Images (ref_uid for image items)",
    "Itemsâ†’Texts (ref_uid for text items)",
    "ImageTextPairsâ†’Manifest (input audit)",
    "ImageTextPairsâ†’QCSummary (run metadata)"
  ]
};

let graphData = JSON.parse(JSON.stringify(initialData));
let draggedNode = null;
let draggedLabel = null;
let dragOffset = { x: 0, y: 0 };

// ---------- checked panel ----------
function renderCheckedPanel() {
  const ulNodes = document.getElementById("checkedNodes");
  const ulEdges = document.getElementById("checkedEdges");
  const badge = document.getElementById("countsBadge");
  ulNodes.innerHTML = "";
  ulEdges.innerHTML = "";

  checkedSpec.nodes.forEach(n => {
    const li = document.createElement("li");
    li.textContent = n;
    ulNodes.appendChild(li);
  });
  checkedSpec.edges.forEach(e => {
    const li = document.createElement("li");
    li.textContent = e;
    ulEdges.appendChild(li);
  });

  badge.textContent = `${checkedSpec.nodes.length} nodes / ${checkedSpec.edges.length} edges`;
}

function setValidationBadge(ok, message) {
  const b = document.getElementById("validatedBadge");
  if (ok) {
    b.textContent = "Validated";
    b.classList.remove("warn");
    b.classList.add("ok");
  } else {
    b.textContent = "Validation issues";
    b.classList.remove("ok");
    b.classList.add("warn");
    if (message) console.warn(message);
  }
}

function isFiniteNumber(x) {
  return typeof x === "number" && Number.isFinite(x);
}

function validateGraph(data) {
  const errors = [];
  if (!data || typeof data !== "object") {
    errors.push("Graph data is not an object.");
    return errors;
  }
  if (!Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
    errors.push("Graph must have 'nodes' and 'edges' arrays.");
    return errors;
  }

  const ids = new Set();
  data.nodes.forEach((n, i) => {
    if (!n || typeof n !== "object") { errors.push(`Node[${i}] is not an object.`); return; }
    if (!n.id || typeof n.id !== "string") errors.push(`Node[${i}] missing valid 'id'.`);
    if (ids.has(n.id)) errors.push(`Duplicate node id: '${n.id}'.`);
    ids.add(n.id);

    ["label","sub1","sub2"].forEach(k => {
      if (typeof n[k] !== "string") errors.push(`Node '${n.id}' missing string '${k}'.`);
    });
    if (!isFiniteNumber(n.x) || !isFiniteNumber(n.y) || !isFiniteNumber(n.r)) {
      errors.push(`Node '${n.id}' has invalid numeric fields (x,y,r).`);
    }
  });

  data.edges.forEach((e, i) => {
    if (!e || typeof e !== "object") { errors.push(`Edge[${i}] is not an object.`); return; }
    if (!ids.has(e.from)) errors.push(`Edge[${i}] from='${e.from}' does not match any node id.`);
    if (!ids.has(e.to)) errors.push(`Edge[${i}] to='${e.to}' does not match any node id.`);
    if (typeof e.label !== "string") errors.push(`Edge[${i}] missing string 'label'.`);
    if (!isFiniteNumber(e.labelX) || !isFiniteNumber(e.labelY)) {
      errors.push(`Edge[${i}] has invalid numeric fields (labelX,labelY).`);
    }
  });

  return errors;
}

function calculateEdgePath(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  const angle = Math.atan2(dy, dx);
  const startX = from.x + from.r * Math.cos(angle);
  const startY = from.y + from.r * Math.sin(angle);
  const endX = to.x - to.r * Math.cos(angle);
  const endY = to.y - to.r * Math.sin(angle);

  if (dist < 300) {
    return `M ${startX} ${startY} L ${endX} ${endY}`;
  } else {
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const offsetX = -(dy) / dist * 50;
    const offsetY = (dx) / dist * 50;
    return `M ${startX} ${startY} Q ${midX + offsetX} ${midY + offsetY} ${endX} ${endY}`;
  }
}

/**
 * ====== WRAPPING (no scaling) ======
 * Wrap sub1/sub2 using tspans based on an estimated max character count.
 * Clip text to circle so nothing renders outside.
 */
function wrapByWords(text, maxCharsPerLine) {
  const s = (text || "").trim();
  if (!s) return [""];
  if (maxCharsPerLine <= 8) return [s];

  const words = s.split(/\s+/);
  const lines = [];
  let cur = "";

  for (const w of words) {
    if (!cur) { cur = w; continue; }
    if ((cur.length + 1 + w.length) <= maxCharsPerLine) cur += " " + w;
    else { lines.push(cur); cur = w; }
  }
  if (cur) lines.push(cur);

  const finalLines = [];
  for (const line of lines) {
    if (line.length <= maxCharsPerLine) finalLines.push(line);
    else {
      let i = 0;
      while (i < line.length) { finalLines.push(line.slice(i, i + maxCharsPerLine)); i += maxCharsPerLine; }
    }
  }
  return finalLines.length ? finalLines : [s];
}

function render() {
  const nodesGroup = document.getElementById('nodes');
  const edgesGroup = document.getElementById('edges');
  nodesGroup.innerHTML = '';
  edgesGroup.innerHTML = '';

  // Edges
  graphData.edges.forEach((edge, idx) => {
    const fromNode = graphData.nodes.find(n => n.id === edge.from);
    const toNode = graphData.nodes.find(n => n.id === edge.to);
    if (!fromNode || !toNode) return;

    const path = calculateEdgePath(fromNode, toNode);

    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const isMetaEdge = (edge.to === "qc" || edge.to === "manifest");
    pathEl.setAttribute('class', isMetaEdge ? 'edgeMeta' : 'edge');
    pathEl.setAttribute('d', path);
    edgesGroup.appendChild(pathEl);

    const labelWidth = edge.label.length * 7 + 20;

    const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    pill.setAttribute('class', isMetaEdge ? 'pillMeta' : 'pill');
    pill.setAttribute('x', edge.labelX - labelWidth / 2);
    pill.setAttribute('y', edge.labelY - 9);
    pill.setAttribute('width', labelWidth);
    pill.setAttribute('height', 18);
    pill.setAttribute('data-edge-idx', idx);
    edgesGroup.appendChild(pill);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('class', 'edgeLabel');
    text.setAttribute('x', edge.labelX);
    text.setAttribute('y', edge.labelY + 3.5);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('data-edge-idx', idx);
    text.textContent = edge.label;
    edgesGroup.appendChild(text);
  });

  // Nodes
  graphData.nodes.forEach((node, idx) => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('data-node-idx', idx);

    // per-node clipPath (circle)
    const clipId = `clip_${node.id}`;
    const defs = document.querySelector('#canvas defs');

    const old = defs.querySelector(`#${clipId}`);
    if (old) old.remove();

    const cp = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
    cp.setAttribute('id', clipId);
    const cpc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    cpc.setAttribute('cx', node.x);
    cpc.setAttribute('cy', node.y);
    cpc.setAttribute('r', node.r);
    cp.appendChild(cpc);
    defs.appendChild(cp);

    // circle
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    const cls = node.meta ? 'nodeMeta' : (node.center ? 'nodeCenter' : 'node');
    circle.setAttribute('class', cls);
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.r);
    g.appendChild(circle);

    // text group clipped to circle
    const tg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    tg.setAttribute('clip-path', `url(#${clipId})`);

    // label (single line)
    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('class', 'label');
    label.setAttribute('x', node.x);
    label.setAttribute('y', node.y - 20);
    label.setAttribute('text-anchor', 'middle');
    label.textContent = node.label;
    tg.appendChild(label);

    // wrap capacity (font unchanged)
    const usablePx = Math.max(40, node.r * 1.55);
    const maxChars = Math.max(10, Math.floor(usablePx / 6.2));

    // sub1 wrapped
    const sub1Lines = wrapByWords(node.sub1, maxChars);
    const sub1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    sub1.setAttribute('class', 'sub');
    sub1.setAttribute('x', node.x);
    sub1.setAttribute('y', node.y + 2);
    sub1.setAttribute('text-anchor', 'middle');
    sub1Lines.forEach((line, i) => {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      t.setAttribute('x', node.x);
      t.setAttribute('dy', i === 0 ? 0 : 12);
      t.textContent = line;
      sub1.appendChild(t);
    });
    tg.appendChild(sub1);

    // sub2 wrapped (below sub1 block)
    const sub2Lines = wrapByWords(node.sub2, maxChars);
    const sub2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    sub2.setAttribute('class', 'sub');
    sub2.setAttribute('x', node.x);
    const sub2StartY = (node.y + 2) + ((sub1Lines.length - 1) * 12) + 14;
    sub2.setAttribute('y', sub2StartY);
    sub2.setAttribute('text-anchor', 'middle');
    sub2Lines.forEach((line, i) => {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      t.setAttribute('x', node.x);
      t.setAttribute('dy', i === 0 ? 0 : 12);
      t.textContent = line;
      sub2.appendChild(t);
    });
    tg.appendChild(sub2);

    g.appendChild(tg);
    nodesGroup.appendChild(g);
  });
}

// Drag interactions
const canvas = document.getElementById('canvas');

canvas.addEventListener('mousedown', (e) => {
  const target = e.target;

  const nodeGroup = target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    draggedNode = idx;
    const node = graphData.nodes[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - node.x, y: svgY - node.y };
    canvas.classList.add('node-dragging');
    return;
  }

  if (target.classList.contains('pill') || target.classList.contains('pillMeta') || target.classList.contains('edgeLabel')) {
    const idx = parseInt(target.getAttribute('data-edge-idx'));
    draggedLabel = idx;
    const edge = graphData.edges[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - edge.labelX, y: svgY - edge.labelY };
    canvas.classList.add('node-dragging');
    return;
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const svgX = (e.clientX - rect.left) * (1600 / rect.width);
  const svgY = (e.clientY - rect.top) * (1000 / rect.height);

  if (draggedNode !== null) {
    graphData.nodes[draggedNode].x = svgX - dragOffset.x;
    graphData.nodes[draggedNode].y = svgY - dragOffset.y;
    render();
  } else if (draggedLabel !== null) {
    graphData.edges[draggedLabel].labelX = svgX - dragOffset.x;
    graphData.edges[draggedLabel].labelY = svgY - dragOffset.y;
    render();
  }
});

function stopDrag() {
  draggedNode = null;
  draggedLabel = null;
  canvas.classList.remove('node-dragging');
}
canvas.addEventListener('mouseup', stopDrag);
canvas.addEventListener('mouseleave', stopDrag);

// Resize node (right-click)
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const nodeGroup = e.target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    const newRadius = prompt('Enter node radius (30-150):', graphData.nodes[idx].r);
    if (newRadius && !isNaN(newRadius)) {
      graphData.nodes[idx].r = Math.max(30, Math.min(150, parseInt(newRadius)));
      render();
    }
  }
});

function updateZoom(value) {
  canvas.style.transform = `scale(${value / 100})`;
  canvas.style.transformOrigin = 'top left';
  document.getElementById('zoomLevel').textContent = value + '%';
}

function saveConfig() {
  const json = JSON.stringify(graphData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'mmf-graph-config.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('Layout JSON saved.');
}

function loadConfig() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const loaded = JSON.parse(event.target.result);
        const errs = validateGraph(loaded);
        if (errs.length) {
          setValidationBadge(false, errs.join("\n"));
          alert("Loaded JSON has validation issues:\n\n" + errs.slice(0, 30).join("\n"));
        } else {
          setValidationBadge(true);
        }
        graphData = loaded;
        render();
      } catch (err) {
        alert('Failed to parse JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function resetGraph() {
  if (confirm('Reset to the ZIP+code-matched MMF layout?')) {
    graphData = JSON.parse(JSON.stringify(initialData));
    const errs = validateGraph(graphData);
    if (errs.length) setValidationBadge(false, errs.join("\n"));
    else setValidationBadge(true);
    render();
    alert('Reset complete.');
  }
}

function downloadSVG() {
  const svg = document.getElementById('canvas').cloneNode(true);
  svg.removeAttribute('style');
  const serializer = new XMLSerializer();
  let src = serializer.serializeToString(svg);
  if (!src.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
    src = src.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const blob = new Blob([src], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'MMF_graph_edited.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('SVG downloaded.');
}

function downloadHTML() {
  const htmlContent = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MMF Graph (Export)</title>
  <style>
    body { margin: 24px; font-family: system-ui; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
  </style>
</head>
<body>
  <h1>MMF Graph (Export)</h1>
  <div class="card">
    ${document.getElementById('canvas').outerHTML}
  </div>
</body>
</html>`;

  const blob = new Blob([htmlContent], {type:'text/html;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'MMF_graph_exported.html';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('HTML downloaded.');
}

// Init
renderCheckedPanel();
const initialErrors = validateGraph(graphData);
setValidationBadge(initialErrors.length === 0, initialErrors.join("\n"));
render();
</script>
</body>
</html>