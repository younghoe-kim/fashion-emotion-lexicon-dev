<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DF2 Schema Graph Interactive Editor (ZIP+Code Matched)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 0;
      padding: 24px;
      color: #111;
      background: #f9fafb;
    }
    .toolbar {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
    }
    button {
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid #111;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: #f6f6f6; }
    .card {
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
      overflow: auto;
    }
    .info {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }
    .checkedPanel{
      background:#ecfeff;
      border:1px solid #06b6d4;
      padding:14px 16px;
      border-radius:10px;
      margin-bottom:16px;
      font-size:13px;
    }
    .checkedPanel h3{
      margin:0 0 10px 0;
      font-size:14px;
    }
    .checkedPanel .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px 18px;
    }
    .checkedPanel ul{ margin:8px 0 0 18px; padding:0; }
    .checkedPanel li{ margin:4px 0; line-height:1.3; }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      border:1px solid #111;
      background:#fff;
      margin-left:8px;
    }
    .badge.ok{ border-color:#16a34a; color:#16a34a; }
    .badge.warn{ border-color:#dc2626; color:#dc2626; }
    .badge.meta{ border-color:#0284c7; color:#0284c7; }
    #canvas { cursor: grab; user-select: none; }
    #canvas.dragging { cursor: grabbing; }
    .node-dragging { cursor: move !important; }
    input[type="range"] { width: 120px; }
    label { font-size: 13px; font-weight: 600; margin-left: 12px; }
    .muted { color:#334155; }
    code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <h1 style="margin:0 0 16px 0;">DF2 Schema Graph Interactive Editor (ZIP + Code Matched)</h1>

  <div class="info">
    <strong>How to use:</strong>
    Drag nodes to reposition | Right-click a node to resize | Drag edge labels to reposition | Save/Load the layout as JSON
    <div class="muted" style="margin-top:6px;">
      This graph is updated to match the DF2 extraction code and the produced ZIP outputs (tables + column schemas).
      It is pair-centric: <code>pair_id</code> is the hub key, while retrieval query/gallery IDs join via <code>image_id_int</code>.
    </div>
  </div>

  <div class="checkedPanel" id="checkedPanel">
    <h3>
      Checked elements
      <span class="badge meta" id="validatedBadge">Validating...</span>
      <span class="badge meta" id="countsBadge"></span>
    </h3>
    <div class="grid">
      <div>
        <strong>Nodes</strong>
        <ul id="checkedNodes"></ul>
      </div>
      <div>
        <strong>Edges</strong>
        <ul id="checkedEdges"></ul>
      </div>
    </div>
    <div style="margin-top:10px; color:#0f172a;">
      <strong>Join semantics (exactly reflecting the extractor behavior):</strong>
      <ul>
        <li><code>Pairs</code> is the hub table keyed by <code>pair_id</code>.</li>
        <li><code>Images</code> preserves both <code>image_id_raw</code> (zero-padded filename stem) and <code>image_id_int</code> (int string).</li>
        <li><code>RetrievalPairs</code> stores query/gallery IDs as seen in retrieval JSONs (often non-padded numeric strings), so the stable join is:
          <br/><span class="small"><code>RetrievalPairs.query_image_id_raw / gallery_image_id_raw</code> â†’ <code>Images.image_id_int</code></span>
        </li>
        <li><code>Items</code>, <code>BBox</code>, <code>Segmentation</code>, <code>KeypointsRaw</code>, <code>QualityFlags</code> are item-centric and join via <code>item_uid</code>.</li>
        <li><code>QCSummary</code> is run-level metadata; the edge from <code>Pairs</code> is conceptual (not a FK) and is rendered as a <strong>black dashed</strong> edge.</li>
      </ul>
    </div>
  </div>

  <div class="toolbar">
    <button onclick="downloadSVG()">ðŸ“¥ Download SVG</button>
    <button onclick="downloadHTML()">ðŸ“¥ Download HTML</button>
    <button onclick="saveConfig()">ðŸ’¾ Save Layout (JSON)</button>
    <button onclick="loadConfig()">ðŸ“‚ Load Layout</button>
    <button onclick="resetGraph()">ðŸ”„ Reset</button>
    <label>Zoom: <input type="range" id="zoomSlider" min="50" max="150" value="100" oninput="updateZoom(this.value)"></label>
    <span id="zoomLevel">100%</span>
  </div>

  <div class="card">
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg" width="1600" height="1000" viewBox="0 0 1600 1000">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#111"/>
        </marker>
        <style>
          .node { fill:#fff; stroke:#111; stroke-width:2.2; cursor: move; }
          .node:hover { stroke:#0066cc; stroke-width:3; }
          .nodeCenter { fill:#f0f9ff; stroke:#0066cc; stroke-width:2.5; cursor: move; }
          .nodeCenter:hover { stroke:#0044aa; stroke-width:3; }

          /* Meta node (QC) */
          .nodeMeta { fill:#fff7ed; stroke:#111; stroke-width:2.3; cursor: move; }
          .nodeMeta:hover { stroke:#111; stroke-width:3; }

          .label { font:700 13px system-ui; fill:#111; pointer-events: none; }
          .sub { font:400 10.5px system-ui; fill:#555; pointer-events: none; }

          .edge { stroke:#111; stroke-width:2.1; fill:none; marker-end:url(#arrow); }

          /* Meta edge: black dashed */
          .edgeMeta { stroke:#111; stroke-width:2.1; fill:none; marker-end:url(#arrow); stroke-dasharray:7 6; }

          .edgeLabel { font:600 11px system-ui; fill:#111; cursor: move; }
          .pill { fill:#f3f4f6; stroke:#111; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pill:hover { fill:#e5e7eb; }

          /* Meta pill: black dashed-ish look */
          .pillMeta { fill:#fff7ed; stroke:#111; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pillMeta:hover { fill:#ffedd5; }
        </style>
      </defs>
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
  </div>

<script>
/**
 * DF2 graph layout and schema labels updated to match:
 * - the DF2 extractor code (writers + column headers)
 * - the produced ZIP outputs (normalized/*.csv.gz, *.jsonl.gz, qc_summary.json)
 *
 * NOTE (ZIP verified):
 * - normalized/ contains:
 *   pairs.csv.gz, images.csv.gz, items.csv.gz, pair_items.csv.gz, bbox.csv.gz,
 *   quality_flags.csv.gz, retrieval_pairs.csv.gz, segmentation.jsonl.gz, keypoints_raw.jsonl.gz
 * - qc_summary.json exists at out_dir root
 */

const initialData = {
  "nodes": [
    {
      "id": "pairs",
      "label": "Pairs",
      "sub1": "pairs.csv.gz",
      "sub2": "(pair_id, query_image_id_raw, gallery_image_id_raw, split, src_file, row_index)",
      "x": 898,
      "y": 527,
      "r": 95,
      "center": true
    },
    {
      "id": "images",
      "label": "Images",
      "sub1": "images.csv.gz",
      "sub2": "(image_uid, image_id_raw, image_id_int, pair_id, split, src_file)",
      "x": 813,
      "y": 216,
      "r": 80
    },
    {
      "id": "items",
      "label": "Items",
      "sub1": "items.csv.gz",
      "sub2": "(item_uid, pair_id, image_id_raw, slot, role, split, src_file)",
      "x": 527,
      "y": 323,
      "r": 80
    },
    {
      "id": "pairItems",
      "label": "PairItems",
      "sub1": "pair_items.csv.gz",
      "sub2": "(pair_item_uid, pair_id, image_id_raw, item_uid, role, split, src_file)",
      "x": 1136,
      "y": 299,
      "r": 85
    },
    {
      "id": "bbox",
      "label": "BBox",
      "sub1": "bbox.csv.gz",
      "sub2": "(item_uid, x1, y1, x2, y2, bbox_format, split, src_file)",
      "x": 260,
      "y": 186,
      "r": 75
    },
    {
      "id": "seg",
      "label": "Segmentation",
      "sub1": "segmentation.jsonl.gz",
      "sub2": "(item_uid, pair_id, split, segmentation, src_file)",
      "x": 157,
      "y": 345,
      "r": 75
    },
    {
      "id": "kpt",
      "label": "KeypointsRaw",
      "sub1": "keypoints_raw.jsonl.gz",
      "sub2": "(item_uid, pair_id, split, keypoints, src_file)",
      "x": 177,
      "y": 514,
      "r": 75
    },
    {
      "id": "qf",
      "label": "QualityFlags",
      "sub1": "quality_flags.csv.gz",
      "sub2": "(item_uid, occlusion, viewpoint, scale, zoom_in, split, src_file)",
      "x": 344,
      "y": 583,
      "r": 80
    },
    {
      "id": "retrieval",
      "label": "RetrievalPairs",
      "sub1": "retrieval_pairs.csv.gz",
      "sub2": "(pair_id, query_image_id_raw, gallery_image_id_raw, split, src_file, row_index)",
      "x": 566,
      "y": 647,
      "r": 85
    },
    {
      "id": "qc",
      "label": "QCSummary",
      "sub1": "qc_summary.json",
      "sub2": "(counts, warnings, errors, examples, inputs, policy, version...)",
      "x": 1170,
      "y": 670,
      "r": 75,
      "meta": true
    }
  ],
  "edges": [
    { "from": "pairs", "to": "images", "label": "pair_id", "labelX": 888, "labelY": 388 },
    { "from": "pairs", "to": "items", "label": "pair_id", "labelX": 766, "labelY": 437 },
    { "from": "pairs", "to": "pairItems", "label": "pair_id", "labelX": 1036, "labelY": 430 },

    { "from": "images", "to": "items", "label": "image_id_raw", "labelX": 650, "labelY": 260 },
    { "from": "items", "to": "pairItems", "label": "item_uid", "labelX": 811, "labelY": 337 },

    { "from": "items", "to": "bbox", "label": "item_uid", "labelX": 418, "labelY": 246 },
    { "from": "items", "to": "qf", "label": "item_uid", "labelX": 430, "labelY": 430 },
    { "from": "items", "to": "seg", "label": "item_uid", "labelX": 346, "labelY": 307 },
    { "from": "items", "to": "kpt", "label": "item_uid", "labelX": 366, "labelY": 377 },

    { "from": "pairs", "to": "retrieval", "label": "pair_id", "labelX": 712, "labelY": 569 },

    // IMPORTANT (ZIP+code matched):
    // retrieval query/gallery IDs commonly come as non-padded numeric strings;
    // therefore they join to Images via image_id_int (not image_id_raw).
    { "from": "images", "to": "retrieval", "label": "image_id_int (join)", "labelX": 632, "labelY": 471 },

    // Run-level metadata edge (conceptual; not a FK) -> black dashed
    { "from": "pairs", "to": "qc", "label": "run metadata", "labelX": 1017, "labelY": 618 }
  ]
};

const checkedSpec = {
  nodes: [
    "Pairs (pairs.csv.gz)",
    "Images (images.csv.gz)",
    "Items (items.csv.gz)",
    "PairItems (pair_items.csv.gz)",
    "BBox (bbox.csv.gz)",
    "Segmentation (segmentation.jsonl.gz)",
    "KeypointsRaw (keypoints_raw.jsonl.gz)",
    "QualityFlags (quality_flags.csv.gz)",
    "RetrievalPairs (retrieval_pairs.csv.gz)",
    "QCSummary (qc_summary.json)"
  ],
  edges: [
    "Pairsâ†’Images (pair_id)",
    "Pairsâ†’Items (pair_id)",
    "Pairsâ†’PairItems (pair_id)",
    "Imagesâ†’Items (image_id_raw)",
    "Itemsâ†’PairItems (item_uid)",
    "Itemsâ†’BBox (item_uid)",
    "Itemsâ†’QualityFlags (item_uid)",
    "Itemsâ†’Segmentation (item_uid)",
    "Itemsâ†’KeypointsRaw (item_uid)",
    "Pairsâ†’RetrievalPairs (pair_id)",
    "Imagesâ†’RetrievalPairs (image_id_int join)",
    "Pairsâ†’QCSummary (run metadata; dashed)"
  ]
};

let graphData = JSON.parse(JSON.stringify(initialData));
let draggedNode = null;
let draggedLabel = null;
let dragOffset = { x: 0, y: 0 };

function renderCheckedPanel() {
  const ulNodes = document.getElementById("checkedNodes");
  const ulEdges = document.getElementById("checkedEdges");
  const badge = document.getElementById("countsBadge");
  ulNodes.innerHTML = "";
  ulEdges.innerHTML = "";

  checkedSpec.nodes.forEach(n => {
    const li = document.createElement("li");
    li.textContent = n;
    ulNodes.appendChild(li);
  });
  checkedSpec.edges.forEach(e => {
    const li = document.createElement("li");
    li.textContent = e;
    ulEdges.appendChild(li);
  });

  badge.textContent = `${checkedSpec.nodes.length} nodes / ${checkedSpec.edges.length} edges`;
}

function setValidationBadge(ok, message) {
  const b = document.getElementById("validatedBadge");
  if (ok) {
    b.textContent = "Validated";
    b.classList.remove("warn");
    b.classList.add("ok");
  } else {
    b.textContent = "Validation issues";
    b.classList.remove("ok");
    b.classList.add("warn");
    if (message) console.warn(message);
  }
}

function isFiniteNumber(x) {
  return typeof x === "number" && Number.isFinite(x);
}

function validateGraph(data) {
  const errors = [];
  if (!data || typeof data !== "object") {
    errors.push("Graph data is not an object.");
    return errors;
  }
  if (!Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
    errors.push("Graph must have 'nodes' and 'edges' arrays.");
    return errors;
  }

  const ids = new Set();
  data.nodes.forEach((n, i) => {
    if (!n || typeof n !== "object") { errors.push(`Node[${i}] is not an object.`); return; }
    if (!n.id || typeof n.id !== "string") errors.push(`Node[${i}] missing valid 'id'.`);
    if (ids.has(n.id)) errors.push(`Duplicate node id: '${n.id}'.`);
    ids.add(n.id);

    ["label","sub1","sub2"].forEach(k => {
      if (typeof n[k] !== "string") errors.push(`Node '${n.id}' missing string '${k}'.`);
    });
    if (!isFiniteNumber(n.x) || !isFiniteNumber(n.y) || !isFiniteNumber(n.r)) {
      errors.push(`Node '${n.id}' has invalid numeric fields (x,y,r).`);
    }
  });

  data.edges.forEach((e, i) => {
    if (!e || typeof e !== "object") { errors.push(`Edge[${i}] is not an object.`); return; }
    if (!ids.has(e.from)) errors.push(`Edge[${i}] from='${e.from}' does not match any node id.`);
    if (!ids.has(e.to)) errors.push(`Edge[${i}] to='${e.to}' does not match any node id.`);
    if (typeof e.label !== "string") errors.push(`Edge[${i}] missing string 'label'.`);
    if (!isFiniteNumber(e.labelX) || !isFiniteNumber(e.labelY)) {
      errors.push(`Edge[${i}] has invalid numeric fields (labelX,labelY).`);
    }
  });

  return errors;
}

/* =========================
   Text wrapping inside circle (no font shrinking, no stretching)
   - Wrap long strings to fit node diameter.
   - Up to 4 total lines (2 from sub1 + 2 from sub2) with ellipsis.
   ========================= */
function estimateTextWidthPx(text, fontSizePx) {
  return String(text).length * fontSizePx * 0.58;
}

function wrapTextToRadius(text, radius, fontSizePx, paddingPx = 18, maxLines = 2) {
  const maxWidth = Math.max(20, (radius * 2) - paddingPx);
  if (!text) return [];

  const words = String(text).split(/\s+/);
  const lines = [];
  let line = "";

  const pushLine = (l) => { if (l.trim()) lines.push(l.trim()); };

  for (let w of words) {
    const candidate = line ? (line + " " + w) : w;
    if (estimateTextWidthPx(candidate, fontSizePx) <= maxWidth) {
      line = candidate;
      continue;
    }

    if (line) pushLine(line);

    if (estimateTextWidthPx(w, fontSizePx) > maxWidth) {
      let chunk = "";
      for (const ch of w) {
        const cand2 = chunk + ch;
        if (estimateTextWidthPx(cand2, fontSizePx) <= maxWidth) {
          chunk = cand2;
        } else {
          pushLine(chunk);
          chunk = ch;
        }
        if (lines.length >= maxLines) break;
      }
      line = chunk;
    } else {
      line = w;
    }

    if (lines.length >= maxLines) break;
  }

  if (lines.length < maxLines) pushLine(line);
  if (lines.length > maxLines) lines.length = maxLines;

  if (lines.length === maxLines) {
    let last = lines[maxLines - 1];
    while (estimateTextWidthPx(last + "â€¦", fontSizePx) > maxWidth && last.length > 0) {
      last = last.slice(0, -1);
    }
    if (last !== lines[maxLines - 1]) lines[maxLines - 1] = last + "â€¦";
  }
  return lines;
}

function calculateEdgePath(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;

  const angle = Math.atan2(dy, dx);
  const startX = from.x + from.r * Math.cos(angle);
  const startY = from.y + from.r * Math.sin(angle);
  const endX = to.x - to.r * Math.cos(angle);
  const endY = to.y - to.r * Math.sin(angle);

  if (dist < 300) {
    return `M ${startX} ${startY} L ${endX} ${endY}`;
  } else {
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const offsetX = -(dy) / dist * 50;
    const offsetY = (dx) / dist * 50;
    return `M ${startX} ${startY} Q ${midX + offsetX} ${midY + offsetY} ${endX} ${endY}`;
  }
}

function render() {
  const nodesGroup = document.getElementById('nodes');
  const edgesGroup = document.getElementById('edges');
  nodesGroup.innerHTML = '';
  edgesGroup.innerHTML = '';

  // Edges
  graphData.edges.forEach((edge, idx) => {
    const fromNode = graphData.nodes.find(n => n.id === edge.from);
    const toNode = graphData.nodes.find(n => n.id === edge.to);
    if (!fromNode || !toNode) return;

    const path = calculateEdgePath(fromNode, toNode);

    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const isMetaEdge = (edge.to === "qc"); // only run-metadata is dashed
    pathEl.setAttribute('class', isMetaEdge ? 'edgeMeta' : 'edge');
    pathEl.setAttribute('d', path);
    edgesGroup.appendChild(pathEl);

    const labelWidth = (edge.label || "").length * 7 + 20;

    const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    pill.setAttribute('class', isMetaEdge ? 'pillMeta' : 'pill');
    pill.setAttribute('x', edge.labelX - labelWidth / 2);
    pill.setAttribute('y', edge.labelY - 9);
    pill.setAttribute('width', labelWidth);
    pill.setAttribute('height', 18);
    pill.setAttribute('data-edge-idx', idx);
    edgesGroup.appendChild(pill);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('class', 'edgeLabel');
    text.setAttribute('x', edge.labelX);
    text.setAttribute('y', edge.labelY + 3.5);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('data-edge-idx', idx);
    text.textContent = edge.label;
    edgesGroup.appendChild(text);
  });

  // Nodes
  graphData.nodes.forEach((node, idx) => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('data-node-idx', idx);

    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    const cls = node.meta ? 'nodeMeta' : (node.center ? 'nodeCenter' : 'node');
    circle.setAttribute('class', cls);
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.r);
    g.appendChild(circle);

    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    label.setAttribute('class', 'label');
    label.setAttribute('x', node.x);
    label.setAttribute('y', node.y - 15);
    label.setAttribute('text-anchor', 'middle');
    label.textContent = node.label;
    g.appendChild(label);

    // Wrapped sub text lines (no font resizing, no stretching)
    const SUB_FONT = 10.5;
    const lines1 = wrapTextToRadius(node.sub1, node.r, SUB_FONT, 18, 2);
    const lines2 = wrapTextToRadius(node.sub2, node.r, SUB_FONT, 18, 2);
    const allLines = [...lines1, ...lines2];

    const MAX_TOTAL_LINES = 4;
    const finalLines = allLines.slice(0, MAX_TOTAL_LINES);
    if (allLines.length > MAX_TOTAL_LINES && finalLines.length) {
      finalLines[finalLines.length - 1] = finalLines[finalLines.length - 1].replace(/â€¦?$/, "â€¦");
    }

    const startY = node.y + 3;
    const lineGap = 12;
    finalLines.forEach((ln, i) => {
      const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      t.setAttribute('class', 'sub');
      t.setAttribute('x', node.x);
      t.setAttribute('y', startY + i * lineGap);
      t.setAttribute('text-anchor', 'middle');
      t.textContent = ln;
      g.appendChild(t);
    });

    nodesGroup.appendChild(g);
  });
}

// Drag interactions
const canvas = document.getElementById('canvas');

canvas.addEventListener('mousedown', (e) => {
  const target = e.target;

  const nodeGroup = target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    draggedNode = idx;
    const node = graphData.nodes[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - node.x, y: svgY - node.y };
    canvas.classList.add('node-dragging');
    return;
  }

  if (target.classList.contains('pill') || target.classList.contains('pillMeta') || target.classList.contains('edgeLabel')) {
    const idx = parseInt(target.getAttribute('data-edge-idx'));
    draggedLabel = idx;
    const edge = graphData.edges[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - edge.labelX, y: svgY - edge.labelY };
    canvas.classList.add('node-dragging');
    return;
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const svgX = (e.clientX - rect.left) * (1600 / rect.width);
  const svgY = (e.clientY - rect.top) * (1000 / rect.height);

  if (draggedNode !== null) {
    graphData.nodes[draggedNode].x = svgX - dragOffset.x;
    graphData.nodes[draggedNode].y = svgY - dragOffset.y;
    render();
  } else if (draggedLabel !== null) {
    graphData.edges[draggedLabel].labelX = svgX - dragOffset.x;
    graphData.edges[draggedLabel].labelY = svgY - dragOffset.y;
    render();
  }
});

function stopDrag() {
  draggedNode = null;
  draggedLabel = null;
  canvas.classList.remove('node-dragging');
}
canvas.addEventListener('mouseup', stopDrag);
canvas.addEventListener('mouseleave', stopDrag);

// Resize node (right-click)
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const nodeGroup = e.target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    const newRadius = prompt('Enter node radius (30-150):', graphData.nodes[idx].r);
    if (newRadius && !isNaN(newRadius)) {
      graphData.nodes[idx].r = Math.max(30, Math.min(150, parseInt(newRadius)));
      render();
    }
  }
});

function updateZoom(value) {
  canvas.style.transform = `scale(${value / 100})`;
  canvas.style.transformOrigin = 'top left';
  document.getElementById('zoomLevel').textContent = value + '%';
}

function saveConfig() {
  const json = JSON.stringify(graphData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'df2-graph-config.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('Layout JSON saved.');
}

function loadConfig() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const loaded = JSON.parse(event.target.result);
        const errs = validateGraph(loaded);
        if (errs.length) {
          setValidationBadge(false, errs.join("\n"));
          alert("Loaded JSON has validation issues:\n\n" + errs.slice(0, 30).join("\n"));
        } else {
          setValidationBadge(true);
        }
        graphData = loaded;
        render();
      } catch (err) {
        alert('Failed to parse JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function resetGraph() {
  if (confirm('Reset to the ZIP+code-matched DF2 layout?')) {
    graphData = JSON.parse(JSON.stringify(initialData));
    const errs = validateGraph(graphData);
    if (errs.length) setValidationBadge(false, errs.join("\n"));
    else setValidationBadge(true);
    render();
    alert('Reset complete.');
  }
}

function downloadSVG() {
  const svg = document.getElementById('canvas').cloneNode(true);
  svg.removeAttribute('style');
  const serializer = new XMLSerializer();
  let src = serializer.serializeToString(svg);
  if (!src.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
    src = src.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const blob = new Blob([src], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'DF2_graph_updated.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('SVG downloaded.');
}

function downloadHTML() {
  const htmlContent = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DF2 Graph (Export)</title>
  <style>
    body { margin: 24px; font-family: system-ui; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
  </style>
</head>
<body>
  <h1>DF2 Graph (Export)</h1>
  <div class="card">
    ${document.getElementById('canvas').outerHTML}
  </div>
</body>
</html>`;

  const blob = new Blob([htmlContent], {type:'text/html;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'DF2_graph_exported.html';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('HTML downloaded.');
}

// Init
renderCheckedPanel();
const initialErrors = validateGraph(graphData);
setValidationBadge(initialErrors.length === 0, initialErrors.join("\n"));
render();
</script>
</body>
</html>