<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Fashionpedia Schema Graph Interactive Editor (ZIP+Code Matched)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 0;
      padding: 24px;
      color: #111;
      background: #f9fafb;
    }
    .toolbar {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
    }
    button {
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid #111;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: #f6f6f6; }
    .card {
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,.06);
      overflow: auto;
    }
    .info {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
    }
    .checkedPanel{
      background:#ecfeff;
      border:1px solid #06b6d4;
      padding:14px 16px;
      border-radius:10px;
      margin-bottom:16px;
      font-size:13px;
    }
    .checkedPanel h3{
      margin:0 0 10px 0;
      font-size:14px;
    }
    .checkedPanel .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px 18px;
    }
    .checkedPanel ul{ margin:8px 0 0 18px; padding:0; }
    .checkedPanel li{ margin:4px 0; line-height:1.3; }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:700;
      border:1px solid #111;
      background:#fff;
      margin-left:8px;
    }
    .badge.ok{ border-color:#16a34a; color:#16a34a; }
    .badge.warn{ border-color:#dc2626; color:#dc2626; }
    .badge.meta{ border-color:#0284c7; color:#0284c7; }

    #canvas { cursor: grab; user-select: none; }
    #canvas.dragging { cursor: grabbing; }
    .node-dragging { cursor: move !important; }
    input[type="range"] { width: 120px; }
    label { font-size: 13px; font-weight: 600; margin-left: 12px; }
    .muted { color:#334155; }
    code { background:#f1f5f9; padding:2px 6px; border-radius:6px; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <h1 style="margin:0 0 16px 0;">Fashionpedia Schema Graph Interactive Editor (ZIP + Code Matched)</h1>

  <div class="info">
    <strong>How to use:</strong>
    Drag nodes to reposition | Right-click a node to resize | Drag edge labels to reposition | Save/Load the layout as JSON
    <div class="muted" style="margin-top:6px;">
      This graph matches the Fashionpedia extractor outputs in <code>out_dir/normalized/</code> plus <code>qc_summary.json</code> at <code>out_dir</code> root.
      Text wrapping is implemented via SVG <code>&lt;tspan&gt;</code> (no font scaling / no sideways stretching).
    </div>
  </div>

  <div class="checkedPanel" id="checkedPanel">
    <h3>
      Checked elements
      <span class="badge meta" id="validatedBadge">Validating...</span>
      <span class="badge meta" id="countsBadge"></span>
    </h3>
    <div class="grid">
      <div>
        <strong>Nodes</strong>
        <ul id="checkedNodes"></ul>
      </div>
      <div>
        <strong>Edges</strong>
        <ul id="checkedEdges"></ul>
      </div>
    </div>
    <div style="margin-top:10px; color:#0f172a;">
      <strong>Join semantics (extractor-faithful):</strong>
      <ul>
        <li><code>fp_images_index.csv.gz</code> is the hub keyed by <code>image_uid</code> (<code>FP:img/&lt;image_id&gt;</code>).</li>
        <li><code>items.csv.gz</code> (Items) joins to Images via <code>ref_uid (=image_uid)</code>.</li>
        <li><code>fp_instances.csv.gz</code> joins to images via <code>image_uid</code> and to categories via <code>fp_cat_id</code>.</li>
        <li><code>fp_attr_sparse.csv.gz</code> joins to images via <code>image_uid</code> and to attributes via <code>fp_attr_id</code>.</li>
        <li><code>fp_image_categories.csv.gz</code> is a per-instance category log; <code>fp_image_categories_agg.csv.gz</code> aggregates it.</li>
        <li><code>fp_geometry.csv.gz</code> is derived from non-part instances (union/primary bbox) per <code>image_uid</code>.</li>
        <li><code>manifest.csv/jsonl</code>, <code>report.md</code>, <code>qc_summary.json</code> are run-level artifacts (conceptual edges).</li>
      </ul>
    </div>
  </div>

  <div class="toolbar">
    <button onclick="downloadSVG()">ðŸ“¥ Download SVG</button>
    <button onclick="downloadHTML()">ðŸ“¥ Download HTML</button>
    <button onclick="saveConfig()">ðŸ’¾ Save Layout (JSON)</button>
    <button onclick="loadConfig()">ðŸ“‚ Load Layout</button>
    <button onclick="resetGraph()">ðŸ”„ Reset</button>
    <label>Zoom: <input type="range" id="zoomSlider" min="50" max="150" value="100" oninput="updateZoom(this.value)"></label>
    <span id="zoomLevel">100%</span>
  </div>

  <div class="card">
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg" width="1600" height="1000" viewBox="0 0 1600 1000">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="#111"/>
        </marker>
        <style>
          .node { fill:#fff; stroke:#111; stroke-width:2.2; cursor: move; }
          .node:hover { stroke:#0066cc; stroke-width:3; }
          .nodeCenter { fill:#f0f9ff; stroke:#0066cc; stroke-width:2.5; cursor: move; }
          .nodeCenter:hover { stroke:#0044aa; stroke-width:3; }
          .nodeMeta { fill:#fff7ed; stroke:#c2410c; stroke-width:2.3; cursor: move; }
          .nodeMeta:hover { stroke:#9a3412; stroke-width:3; }

          .label { font:700 13px system-ui; fill:#111; pointer-events: none; }
          .sub { font:400 10.5px system-ui; fill:#555; pointer-events: none; }

          .edge { stroke:#111; stroke-width:2.1; fill:none; marker-end:url(#arrow); }
          .edgeMeta { stroke:#c2410c; stroke-width:2.1; fill:none; marker-end:url(#arrow); stroke-dasharray:7 6; }

          .edgeLabel { font:600 11px system-ui; fill:#111; cursor: move; }
          .pill { fill:#f3f4f6; stroke:#111; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pill:hover { fill:#e5e7eb; }
          .pillMeta { fill:#fff7ed; stroke:#c2410c; stroke-width:1.4; rx:999; ry:999; cursor: move; }
          .pillMeta:hover { fill:#ffedd5; }
        </style>
      </defs>
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
  </div>

<script>
/**
 * Fashionpedia layout & schema labels updated to match the provided graph-config JSON.
 * IMPORTANT: sub text is wrapped via tspans (no scaling / no stretching).
 */

// âœ… UPDATED from uploaded fashionpedia-graph-config.json (as-is)
const initialData = {
  "nodes": [
    {
      "id": "images",
      "label": "ImagesIndex",
      "sub1": "fp_images_index.csv.gz",
      "sub2": "(image_uid, image_id, file_name, width, height, split, sources)",
      "x": 820,
      "y": 460,
      "r": 115,
      "center": true
    },
    {
      "id": "items",
      "label": "Items",
      "sub1": "items.csv.gz",
      "sub2": "(item_uid, ref_uid (=image_uid), split)",
      "x": 1192.7272727272725,
      "y": 314.0909090909091,
      "r": 92
    },
    {
      "id": "inst",
      "label": "Instances",
      "sub1": "fp_instances.csv.gz",
      "sub2": "(instance_id, instance_uid, image_uid, fp_cat_id, bbox_xywh, seg_summary, attrs_json, is_degenerate_bbox, ...)",
      "x": 1022.8787878787878,
      "y": 150,
      "r": 95
    },
    {
      "id": "attrSparse",
      "label": "AttrSparse",
      "sub1": "fp_attr_sparse.csv.gz",
      "sub2": "(image_uid, fp_attr_id, value, split, src_file, row_index)",
      "x": 762.4242424242425,
      "y": 173.03030303030303,
      "r": 95
    },
    {
      "id": "imgCatLog",
      "label": "ImageCategories",
      "sub1": "fp_image_categories.csv.gz",
      "sub2": "(image_uid, fp_cat_id, term_role, split, src_file, row_index)",
      "x": 1321.3636363636363,
      "y": 728.030303030303,
      "r": 95
    },
    {
      "id": "imgCatAgg",
      "label": "ImageCategoriesAgg",
      "sub1": "fp_image_categories_agg.csv.gz",
      "sub2": "(image_uid, fp_cat_id, term_role, split, instance_count)",
      "x": 1467.272727272727,
      "y": 444.69696969697,
      "r": 98
    },
    {
      "id": "geom",
      "label": "Geometry",
      "sub1": "fp_geometry.csv.gz",
      "sub2": "(image_uid, primary_bbox, union_bbox, num_garment_instances)",
      "x": 837.2727272727273,
      "y": 890,
      "r": 92
    },
    {
      "id": "termsCat",
      "label": "TermsCategories",
      "sub1": "fp_terms_categories.csv",
      "sub2": "(fp_cat_id, taxonomy_id, name, supercategory, level, term_role)",
      "x": 1366.2121212121208,
      "y": 164.2424242424242,
      "r": 90
    },
    {
      "id": "termsAttr",
      "label": "TermsAttributes",
      "sub1": "fp_terms_attributes.csv",
      "sub2": "(fp_attr_id, taxonomy_id, name, supercategory, level)",
      "x": 494.54545454545456,
      "y": 377.57575757575756,
      "r": 90
    },
    {
      "id": "manifest",
      "label": "Manifest",
      "sub1": "manifest.csv",
      "sub2": "manifest.jsonl",
      "x": 488.18181818181813,
      "y": 623.1818181818181,
      "r": 90
    },
    {
      "id": "report",
      "label": "Report",
      "sub1": "report.md",
      "sub2": "(extract summary, warnings/errors, outputs list)",
      "x": 611.5151515151515,
      "y": 820.3030303030304,
      "r": 85
    },
    {
      "id": "qc",
      "label": "QCSummary",
      "sub1": "qc_summary.json",
      "sub2": "(counts, integrity, warnings, errors, hard_fail, inputs, policy)",
      "x": 1080.4545454545453,
      "y": 851.5151515151516,
      "r": 95,
      "meta": true
    }
  ],
  "edges": [
    {
      "from": "images",
      "to": "items",
      "label": "image_uid (=ref_uid)",
      "labelX": 1038.1818181818185,
      "labelY": 396.96969696969694
    },
    {
      "from": "images",
      "to": "inst",
      "label": "image_uid",
      "labelX": 949.6969696969697,
      "labelY": 308.030303030303
    },
    {
      "from": "images",
      "to": "attrSparse",
      "label": "image_uid",
      "labelX": 785.1515151515152,
      "labelY": 318.1818181818182
    },
    {
      "from": "images",
      "to": "imgCatLog",
      "label": "image_uid",
      "labelX": 1066.818181818182,
      "labelY": 620.6060606060606
    },
    {
      "from": "imgCatLog",
      "to": "imgCatAgg",
      "label": "aggregate",
      "labelX": 1412.4242424242423,
      "labelY": 600.6060606060606
    },
    {
      "from": "images",
      "to": "geom",
      "label": "image_uid",
      "labelX": 807.5757575757575,
      "labelY": 672.7272727272727
    },
    {
      "from": "termsCat",
      "to": "inst",
      "label": "fp_cat_id",
      "labelX": 1198.030303030303,
      "labelY": 134.6969696969697
    },
    {
      "from": "termsCat",
      "to": "imgCatLog",
      "label": "fp_cat_id",
      "labelX": 1323.4848484848485,
      "labelY": 427.5757575757575
    },
    {
      "from": "termsAttr",
      "to": "attrSparse",
      "label": "fp_attr_id",
      "labelX": 639.6969696969697,
      "labelY": 291.81818181818176
    },
    {
      "from": "images",
      "to": "manifest",
      "label": "input audit",
      "labelX": 629.6969696969696,
      "labelY": 532.8787878787879
    },
    {
      "from": "images",
      "to": "report",
      "label": "report",
      "labelX": 689.5454545454545,
      "labelY": 631.2121212121212
    },
    {
      "from": "images",
      "to": "qc",
      "label": "run metadata",
      "labelX": 951.8181818181819,
      "labelY": 684.2424242424242
    }
  ]
};

// Checked spec (updated to match JSON)
const checkedSpec = {
  nodes: [
    "ImagesIndex (fp_images_index.csv.gz)",
    "Items (items.csv.gz)",
    "Instances (fp_instances.csv.gz)",
    "AttrSparse (fp_attr_sparse.csv.gz)",
    "ImageCategories (fp_image_categories.csv.gz)",
    "ImageCategoriesAgg (fp_image_categories_agg.csv.gz)",
    "Geometry (fp_geometry.csv.gz)",
    "TermsCategories (fp_terms_categories.csv)",
    "TermsAttributes (fp_terms_attributes.csv)",
    "Manifest (manifest.csv / manifest.jsonl)",
    "Report (report.md)",
    "QCSummary (qc_summary.json)"
  ],
  edges: [
    "ImagesIndexâ†’Items (image_uid (=ref_uid))",
    "ImagesIndexâ†’Instances (image_uid)",
    "ImagesIndexâ†’AttrSparse (image_uid)",
    "ImagesIndexâ†’ImageCategories (image_uid)",
    "ImageCategoriesâ†’ImageCategoriesAgg (aggregate)",
    "ImagesIndexâ†’Geometry (image_uid)",
    "TermsCategoriesâ†’Instances (fp_cat_id)",
    "TermsCategoriesâ†’ImageCategories (fp_cat_id)",
    "TermsAttributesâ†’AttrSparse (fp_attr_id)",
    "ImagesIndexâ†’Manifest (input audit)",
    "ImagesIndexâ†’Report (report)",
    "ImagesIndexâ†’QCSummary (run metadata)"
  ]
};

let graphData = JSON.parse(JSON.stringify(initialData));
let draggedNode = null;
let draggedLabel = null;
let dragOffset = { x: 0, y: 0 };

function renderCheckedPanel() {
  const ulNodes = document.getElementById("checkedNodes");
  const ulEdges = document.getElementById("checkedEdges");
  const badge = document.getElementById("countsBadge");
  ulNodes.innerHTML = "";
  ulEdges.innerHTML = "";

  checkedSpec.nodes.forEach(n => {
    const li = document.createElement("li");
    li.textContent = n;
    ulNodes.appendChild(li);
  });
  checkedSpec.edges.forEach(e => {
    const li = document.createElement("li");
    li.textContent = e;
    ulEdges.appendChild(li);
  });

  badge.textContent = `${checkedSpec.nodes.length} nodes / ${checkedSpec.edges.length} edges`;
}

function setValidationBadge(ok, message) {
  const b = document.getElementById("validatedBadge");
  if (ok) {
    b.textContent = "Validated";
    b.classList.remove("warn");
    b.classList.add("ok");
  } else {
    b.textContent = "Validation issues";
    b.classList.remove("ok");
    b.classList.add("warn");
    if (message) console.warn(message);
  }
}

function isFiniteNumber(x) {
  return typeof x === "number" && Number.isFinite(x);
}

function validateGraph(data) {
  const errors = [];
  if (!data || typeof data !== "object") {
    errors.push("Graph data is not an object.");
    return errors;
  }
  if (!Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
    errors.push("Graph must have 'nodes' and 'edges' arrays.");
    return errors;
  }

  const ids = new Set();
  data.nodes.forEach((n, i) => {
    if (!n || typeof n !== "object") { errors.push(`Node[${i}] is not an object.`); return; }
    if (!n.id || typeof n.id !== "string") errors.push(`Node[${i}] missing valid 'id'.`);
    if (ids.has(n.id)) errors.push(`Duplicate node id: '${n.id}'.`);
    ids.add(n.id);

    ["label","sub1","sub2"].forEach(k => {
      if (typeof n[k] !== "string") errors.push(`Node '${n.id}' missing string '${k}'.`);
    });
    if (!isFiniteNumber(n.x) || !isFiniteNumber(n.y) || !isFiniteNumber(n.r)) {
      errors.push(`Node '${n.id}' has invalid numeric fields (x,y,r).`);
    }
  });

  data.edges.forEach((e, i) => {
    if (!e || typeof e !== "object") { errors.push(`Edge[${i}] is not an object.`); return; }
    if (!ids.has(e.from)) errors.push(`Edge[${i}] from='${e.from}' does not match any node id.`);
    if (!ids.has(e.to)) errors.push(`Edge[${i}] to='${e.to}' does not match any node id.`);
    if (typeof e.label !== "string") errors.push(`Edge[${i}] missing string 'label'.`);
    if (!isFiniteNumber(e.labelX) || !isFiniteNumber(e.labelY)) {
      errors.push(`Edge[${i}] has invalid numeric fields (labelX,labelY).`);
    }
  });

  return errors;
}

function calculateEdgePath(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  const angle = Math.atan2(dy, dx);
  const startX = from.x + from.r * Math.cos(angle);
  const startY = from.y + from.r * Math.sin(angle);
  const endX = to.x - to.r * Math.cos(angle);
  const endY = to.y - to.r * Math.sin(angle);

  if (dist < 300) {
    return `M ${startX} ${startY} L ${endX} ${endY}`;
  } else {
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const offsetX = -(dy) / dist * 50;
    const offsetY = (dx) / dist * 50;
    return `M ${startX} ${startY} Q ${midX + offsetX} ${midY + offsetY} ${endX} ${endY}`;
  }
}

/**
 * ====== WRAPPING (no scaling) ======
 * We wrap sub1/sub2 using tspans based on an estimated max character count
 * derived from circle radius. This prevents text from leaving the circle
 * WITHOUT changing font size or applying any stretching.
 */
function tokenizeForWrap(s) {
  const out = [];
  let buf = "";
  const seps = new Set([",", ";", ":", "/", "|"]);
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === " ") {
      if (buf) out.push(buf);
      buf = "";
      continue;
    }
    if (seps.has(ch)) {
      if (buf) out.push(buf);
      out.push(ch);
      buf = "";
      continue;
    }
    buf += ch;
  }
  if (buf) out.push(buf);
  return out;
}

function wrapTokensToLines(tokens, maxChars) {
  const lines = [];
  let cur = "";
  const isSep = (t) => t.length === 1 && [",",";",";",":","/","|"].includes(t);

  for (const t of tokens) {
    if (!cur) { cur = t; continue; }
    const cand = isSep(t) ? (cur + t) : (cur + " " + t);

    if (cand.length <= maxChars) {
      cur = cand;
      continue;
    }

    if (!isSep(t) && t.length > maxChars) {
      lines.push(cur);
      let chunk = t;
      while (chunk.length > maxChars) {
        lines.push(chunk.slice(0, maxChars));
        chunk = chunk.slice(maxChars);
      }
      cur = chunk;
      continue;
    }

    lines.push(cur);
    cur = t;
  }
  if (cur) lines.push(cur);
  return lines;
}

function estimateMaxChars(nodeR) {
  const usablePx = nodeR * 1.55;
  const avgCharPx = 6.0;
  return Math.max(12, Math.floor(usablePx / avgCharPx));
}

function createWrappedTextBlock(node) {
  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

  const maxChars = estimateMaxChars(node.r);
  const labelLines = [node.label]; // keep 1-line label
  const sub1Lines = wrapTokensToLines(tokenizeForWrap(node.sub1), maxChars);
  const sub2Lines = wrapTokensToLines(tokenizeForWrap(node.sub2), maxChars);

  const labelLH = 16;
  const subLH = 13;

  const totalHeight =
    (labelLines.length * labelLH) +
    (sub1Lines.length * subLH) +
    (sub2Lines.length * subLH);

  let y = node.y - (totalHeight / 2) + 2;

  for (const ln of labelLines) {
    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    t.setAttribute('class', 'label');
    t.setAttribute('x', node.x);
    t.setAttribute('y', y + labelLH);
    t.setAttribute('text-anchor', 'middle');
    t.textContent = ln;
    g.appendChild(t);
    y += labelLH;
  }

  for (const ln of sub1Lines) {
    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    t.setAttribute('class', 'sub');
    t.setAttribute('x', node.x);
    t.setAttribute('y', y + subLH);
    t.setAttribute('text-anchor', 'middle');
    t.textContent = ln;
    g.appendChild(t);
    y += subLH;
  }

  for (const ln of sub2Lines) {
    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    t.setAttribute('class', 'sub');
    t.setAttribute('x', node.x);
    t.setAttribute('y', y + subLH);
    t.setAttribute('text-anchor', 'middle');
    t.textContent = ln;
    g.appendChild(t);
    y += subLH;
  }

  return g;
}

function render() {
  const nodesGroup = document.getElementById('nodes');
  const edgesGroup = document.getElementById('edges');
  nodesGroup.innerHTML = '';
  edgesGroup.innerHTML = '';

  graphData.edges.forEach((edge, idx) => {
    const fromNode = graphData.nodes.find(n => n.id === edge.from);
    const toNode = graphData.nodes.find(n => n.id === edge.to);
    if (!fromNode || !toNode) return;

    const path = calculateEdgePath(fromNode, toNode);

    const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const isMetaEdge = (edge.to === "qc" || edge.to === "manifest" || edge.to === "report");
    pathEl.setAttribute('class', isMetaEdge ? 'edgeMeta' : 'edge');
    pathEl.setAttribute('d', path);
    edgesGroup.appendChild(pathEl);

    const labelWidth = edge.label.length * 7 + 20;

    const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    pill.setAttribute('class', isMetaEdge ? 'pillMeta' : 'pill');
    pill.setAttribute('x', edge.labelX - labelWidth / 2);
    pill.setAttribute('y', edge.labelY - 9);
    pill.setAttribute('width', labelWidth);
    pill.setAttribute('height', 18);
    pill.setAttribute('data-edge-idx', idx);
    edgesGroup.appendChild(pill);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('class', 'edgeLabel');
    text.setAttribute('x', edge.labelX);
    text.setAttribute('y', edge.labelY + 3.5);
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('data-edge-idx', idx);
    text.textContent = edge.label;
    edgesGroup.appendChild(text);
  });

  graphData.nodes.forEach((node, idx) => {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('data-node-idx', idx);

    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    const cls = node.meta ? 'nodeMeta' : (node.center ? 'nodeCenter' : 'node');
    circle.setAttribute('class', cls);
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.r);
    g.appendChild(circle);

    g.appendChild(createWrappedTextBlock(node));
    nodesGroup.appendChild(g);
  });
}

// Drag interactions
const canvas = document.getElementById('canvas');

canvas.addEventListener('mousedown', (e) => {
  const target = e.target;

  const nodeGroup = target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    draggedNode = idx;
    const node = graphData.nodes[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - node.x, y: svgY - node.y };
    canvas.classList.add('node-dragging');
    return;
  }

  if (target.classList.contains('pill') || target.classList.contains('pillMeta') || target.classList.contains('edgeLabel')) {
    const idx = parseInt(target.getAttribute('data-edge-idx'));
    draggedLabel = idx;
    const edge = graphData.edges[idx];
    const rect = canvas.getBoundingClientRect();
    const svgX = (e.clientX - rect.left) * (1600 / rect.width);
    const svgY = (e.clientY - rect.top) * (1000 / rect.height);
    dragOffset = { x: svgX - edge.labelX, y: svgY - edge.labelY };
    canvas.classList.add('node-dragging');
    return;
  }
});

canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const svgX = (e.clientX - rect.left) * (1600 / rect.width);
  const svgY = (e.clientY - rect.top) * (1000 / rect.height);

  if (draggedNode !== null) {
    graphData.nodes[draggedNode].x = svgX - dragOffset.x;
    graphData.nodes[draggedNode].y = svgY - dragOffset.y;
    render();
  } else if (draggedLabel !== null) {
    graphData.edges[draggedLabel].labelX = svgX - dragOffset.x;
    graphData.edges[draggedLabel].labelY = svgY - dragOffset.y;
    render();
  }
});

function stopDrag() {
  draggedNode = null;
  draggedLabel = null;
  canvas.classList.remove('node-dragging');
}
canvas.addEventListener('mouseup', stopDrag);
canvas.addEventListener('mouseleave', stopDrag);

// Resize node (right-click)
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const nodeGroup = e.target.closest('[data-node-idx]');
  if (nodeGroup) {
    const idx = parseInt(nodeGroup.getAttribute('data-node-idx'));
    const newRadius = prompt('Enter node radius (30-150):', graphData.nodes[idx].r);
    if (newRadius && !isNaN(newRadius)) {
      graphData.nodes[idx].r = Math.max(30, Math.min(150, parseInt(newRadius)));
      render();
    }
  }
});

function updateZoom(value) {
  canvas.style.transform = `scale(${value / 100})`;
  canvas.style.transformOrigin = 'top left';
  document.getElementById('zoomLevel').textContent = value + '%';
}

function saveConfig() {
  const json = JSON.stringify(graphData, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'fashionpedia-graph-config.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('Layout JSON saved.');
}

function loadConfig() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const loaded = JSON.parse(event.target.result);
        const errs = validateGraph(loaded);
        if (errs.length) {
          setValidationBadge(false, errs.join("\n"));
          alert("Loaded JSON has validation issues:\n\n" + errs.slice(0, 30).join("\n"));
        } else {
          setValidationBadge(true);
        }
        graphData = loaded;
        render();
      } catch (err) {
        alert('Failed to parse JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

function resetGraph() {
  if (confirm('Reset to the JSON-provided Fashionpedia layout?')) {
    graphData = JSON.parse(JSON.stringify(initialData));
    const errs = validateGraph(graphData);
    if (errs.length) setValidationBadge(false, errs.join("\n"));
    else setValidationBadge(true);
    render();
    alert('Reset complete.');
  }
}

function downloadSVG() {
  const svg = document.getElementById('canvas').cloneNode(true);
  svg.removeAttribute('style');
  const serializer = new XMLSerializer();
  let src = serializer.serializeToString(svg);
  if (!src.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
    src = src.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  const blob = new Blob([src], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'Fashionpedia_graph.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('SVG downloaded.');
}

function downloadHTML() {
  const htmlContent = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Fashionpedia Graph (Export)</title>
  <style>
    body { margin: 24px; font-family: system-ui; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 16px; }
  </style>
</head>
<body>
  <h1>Fashionpedia Graph (Export)</h1>
  <div class="card">
    ${document.getElementById('canvas').outerHTML}
  </div>
</body>
</html>`;

  const blob = new Blob([htmlContent], {type:'text/html;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'Fashionpedia_graph_exported.html';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 100);
  alert('HTML downloaded.');
}

// Init
renderCheckedPanel();
const initialErrors = validateGraph(graphData);
setValidationBadge(initialErrors.length === 0, initialErrors.join("\n"));
render();
</script>
</body>
</html>